<!DOCTYPE html>

<html lang="ja">
<head><meta content="default-src 'self'; script-src 'self' 'nonce-R4nd0mN0nc3' 'strict-dynamic'; style-src 'self' 'unsafe-inline'; img-src 'self' data: blob:; font-src 'self'; connect-src 'self' data: blob:; media-src 'self'; object-src 'none'; base-uri 'none'; form-action 'self'; frame-ancestors 'self'; worker-src 'self' blob:; manifest-src 'self';" http-equiv="Content-Security-Policy"/>
<script nonce="R4nd0mN0nc3">
  window.SAMPLE_ASSETS = window.SAMPLE_ASSETS || { backgrounds: [], parts: [] };
</script>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>合成エディタ</title>
<style>
  :root { --bg:#f5f5f7; --panel:#ffffff; --border:#dcdce1; --ink:#222; --muted:#6b7280; --primary:#3b82f6; }
  html, body { height:100%; margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans JP, sans-serif; color:var(--ink); background:var(--bg); }
  .topbar { display:flex; align-items:center; gap:.5rem; padding:.5rem .75rem; background:var(--panel); border-bottom:1px solid var(--border); position:sticky; top:0; z-index:10; }
  .btn { padding:.35rem .6rem; border:1px solid var(--border); border-radius:.5rem; background:#fff; cursor:pointer; }
  .btn.primary { background:var(--ink); color:#fff; border-color:#0000; }
  .btn:disabled{ opacity:.6; cursor:not-allowed; }
  .select, .input { border:1px solid var(--border); border-radius:.5rem; padding:.35rem .5rem; background:#fff; }
  .layout { display:flex; height:calc(100% - 46px); }
  .left { width:260px; border-right:1px solid var(--border); background:#fff; overflow:auto; }
  .left .hint { font-size:.85rem; color:var(--muted); padding:.5rem .75rem; }
  .parts { display:grid; gap:.5rem; padding:.5rem; }
  .part { border:1px solid var(--border); border-radius:.5rem; padding:.5rem; background:#fff; text-align:left; }
  .part img { max-width:100%; max-height:96px; object-fit:contain; display:block; margin:auto; }
  .part .name { margin-top:.25rem; font-size:.9rem; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
  .center { flex:1; overflow:auto; background:#e5e7eb; }
  .stage-wrap { padding:1rem; }
  .stage { display:inline-block; background:#fff; box-shadow: 0 2px 12px rgba(0,0,0,.08); }
  canvas { display:block; }
  .foot-hint { color:var(--muted); font-size:.8rem; padding:.25rem .5rem; }
  .part .btn.add { width:100%; margin-top:.35rem; font-size:.85rem; padding:.35rem .5rem; }

  /* Tabs */
  .tabs { display:flex; gap:.5rem; margin-right:.75rem; }
  .tabs .tab { padding:.35rem .6rem; border:1px solid var(--border); border-radius:.5rem; background:#fff; cursor:pointer; }
  .tabs .tab.active { background:var(--ink); color:#fff; border-color:#0000; }
  .hidden { display:none !important; }

  /* Parts management view */
  .parts-manage { padding: 1rem; }
  .parts-manage .toolbar { display:flex; gap:.5rem; align-items:center; margin-bottom: .75rem; flex-wrap:wrap; }
  V0px, 1fr)); gap:.75rem; }
  .pm-card { border:1px solid var(--border); background:#fff; border-radius:.75rem; padding:.5rem; display:flex; gap:.5rem; }
/* -- Emphasize part cards for better separation -- */
.pm-card{
  border: 2px solid var(--border);
  background: #f9fafb;
  border-radius: 0.75rem;
  box-shadow: 0 1px 0 rgba(0,0,0,0.02);
}
.pm-card:hover{
  border-color: #94a3b8; /* slate-400 */
  background: #fff;
}

  .pm-thumb { width:140px; height:140px; border:1px dashed var(--border); display:flex; align-items:center; justify-content:center; overflow:hidden; border-radius:.5rem; background:#fafafa; }
  .pm-thumb img { max-width:100%; max-height:100%; object-fit:contain; }
  .pm-body { flex:1; min-width:0; }
  .pm-colors{ margin:.25rem 0; display:flex; flex-wrap:wrap; gap:.25rem; }
  .chip{ display:inline-block; padding:.1rem .4rem; border:1px solid var(--border); border-radius:999px; font-size:.8em; background:#f6f6f6; }
  .pm-name { font-size:.95rem; font-weight:600; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
  .pm-meta { color:var(--muted); font-size:.75rem; margin-top:.25rem; }
  .pm-actions { display:flex; gap:.35rem; margin-top:.5rem; flex-wrap:wrap; }
  .pm-actions .btn { font-size:.8rem; padding:.3rem .5rem; }

  /* Background management view */
  .bg-manage { padding: 1rem; }
  .bg-manage .toolbar { display:flex; gap:.5rem; align-items:center; margin-bottom: .75rem; flex-wrap:wrap; }
  .bg-grid { display:grid; grid-template-columns: repeat(auto-fill, minmax(260px, 1fr)); gap:.75rem; }
  .bg-card { border:1px solid var(--border); background:#fff; border-radius:.75rem; padding:.5rem; display:flex; gap:.5rem; }
  .bg-thumb { width:110px; height:70px; border:1px dashed var(--border); display:flex; align-items:center; justify-content:center; overflow:hidden; border-radius:.5rem; background:#fafafa; }
  .bg-thumb img { max-width:100%; max-height:100%; object-fit:contain; }
  .bg-body { flex:1; min-width:0; }
  .bg-name { font-size:.95rem; font-weight:600; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
  .bg-meta { color:var(--muted); font-size:.75rem; margin-top:.25rem; }
  .bg-actions { display:flex; gap:.35rem; margin-top:.5rem; flex-wrap:wrap; }
  .bg-actions .btn { font-size:.8rem; padding:.3rem .5rem; }

  /* Parts sort toolbar */
  .parts-toolbar { display:flex; gap:.5rem; align-items:center; padding:.5rem; border-bottom:1px solid var(--border); }
  .parts-toolbar .label { font-size:.85rem; color:var(--muted); }
  /* Inputs in parts-manage */
  .pm-field { display:flex; gap:.4rem; align-items:center; margin-top:.35rem; flex-wrap:wrap; }
  .pm-field label { font-size:.8rem; color:var(--muted); }
  .pm-field input, .pm-field select { padding:.25rem .4rem; border:1px solid var(--border); border-radius:.35rem; }

.pm-card{ padding: .75rem; gap: .75rem; }
.pm-thumb{ border: 1px solid var(--border); background: #fff; }


/* Force two-column layout for Parts Manage grid */
.pm-grid { display:grid; grid-template-columns: repeat(3, minmax(0, 1fr)); gap:.5rem; }
@media (max-width: 720px){
  .pm-grid { grid-template-columns: 1fr; }
}
</style>
<style>
/* ===== Enhanced tab styling to look like real tabs ===== */
.topbar { border-bottom: 1px solid var(--border); }
.tabs { gap: .25rem; }
.tabs .tab{
  border: 1px solid var(--border);
  border-bottom: none;
  border-radius: .6rem .6rem 0 0;
  background: #f9fafb;
  padding: .5rem .8rem;
  transition: background .15s ease, color .15s ease, box-shadow .15s ease;
  position: relative;
  top: 1px; /* sit on the topbar border */
}
.tabs .tab:hover{
  background: #fff;
}
.tabs .tab.active{
  background: #fff;
  color: var(--ink);
  border-color: var(--border);
  box-shadow: 0 1px 0 0 #fff inset; /* hide the topbar border under active tab */
}
/* active underline accent */
.tabs .tab.active::after{
  content: "";
  position: absolute;
  left: .8rem;
  right: .8rem;
  bottom: -1px;
  height: 3px;
  background: var(--primary);
  border-radius: 3px 3px 0 0;
}
/* compact on small screens */
@media (max-width: 640px){
  .tabs .tab{ padding: .4rem .6rem; border-radius: .5rem .5rem 0 0; }
}
</style>
<meta content="#121212" name="theme-color"/>
<link href="./manifest.webmanifest?v=dark" rel="manifest"/>
<link href="icons/icon-192.png" rel="apple-touch-icon"/>
<meta content="yes" name="apple-mobile-web-app-capable"/>
<link href="./icons/192.png" rel="apple-touch-icon"/>
<meta content="yes" name="mobile-web-app-capable"/>
<meta content="black" name="apple-mobile-web-app-status-bar-style"/>
</head>
<body>
<!-- ▼ サンプル自動投入を常時無効化 -->
<script nonce="R4nd0mN0nc3">
  // 初期化の最優先で「投入済み」フラグを立てる
  try { localStorage.setItem("seededSamplesV1", "1"); } catch (e) {}
  // 万一 seedSamples が直接呼ばれても無効化（定義後にも効くよう遅延で上書き）
  (function waitAndNop() {
    const nop = async () => { console.log("[init] seedSamples() は無効化されています"); };
    const apply = () => { if (window.seedSamples) window.seedSamples = nop; };
    apply();
    setTimeout(apply, 0);
    document.addEventListener("DOMContentLoaded", apply);
  })();
  console.log("[init] サンプル自動投入は無効化されています");
</script>
<div class="topbar">
<div class="tabs">
<button class="tab active" id="tabCompose">合成</button>
<button class="tab" id="tabParts">パーツ管理</button>
<button class="tab" id="tabBackgrounds">背景管理</button>
</div>
<select class="select" id="bgSelect"></select>
<label class="btn primary">背景アップロード
      <input accept="image/*" id="bgInput" style="display:none" type="file"/>
</label>
<label class="btn primary">パーツ追加
      <input accept="image/*" id="partInput" style="display:none" type="file"/>
</label>
<div style="margin-left:auto; display:flex; gap:.5rem; align-items:center;">
<button class="btn" id="zoomOut">−</button>
<span id="zoomPct" style="width:3.5rem; text-align:center;">100%</span>
<button class="btn" id="zoomIn">＋</button>
<button class="btn" id="flipBtn">左右反転</button>
<button class="btn" id="dupBtn">複製</button>
<button class="btn" id="layerUpBtn">一つ前面へ</button>
<button class="btn" id="layerDownBtn">一つ背面へ</button>
<button class="btn" id="folderBtn" style="display:none">フォルダ取り込み</button>
<input directory="" id="folderInput" multiple="" style="display:none" type="file" webkitdirectory=""/>
<button class="btn" id="libExportBtn" style="display:none">ライブラリ書き出し(JSON)</button>
<input accept="application/json" id="libImportInput" style="display:none" type="file"/>
<button class="btn" id="libImportBtn" style="display:none">ライブラリ読込(JSON)</button>
<button class="btn" id="exportBtn">PNG出力</button>
<button class="btn" id="tplSaveBtn">★テンプレ登録</button>
<select class="select" id="tplSelect"><option value="">テンプレ適用</option></select>
<button class="btn" id="tplDeleteBtn">テンプレ削除</button>
<button class="btn" id="resetBtn">リセット</button>
</div>
</div>
<div class="layout">
<aside class="left">
<div class="parts-toolbar"><span class="label">抽出:</span> <select class="select" id="filterColorSel"><option value="">色・花材</option></select> <select class="select" id="filterSize"><option value="">サイズ</option><option value="S">S</option><option value="M">M</option><option value="L">L</option><option value="XL">XL</option></select> <button class="btn" id="filterClear">クリア</button></div>
<div class="hint">マイパーツ（クリックで追加）</div>
<div class="parts" id="parts"></div>
</aside>
<main class="center">
<div class="stage-wrap">
<div class="stage" id="stage">
<canvas id="cvs"></canvas>
</div>
<div class="foot-hint">
          操作: ドラッグ=移動 / <b>四隅ハンドル=等比リサイズ</b> / ホイール=拡大縮小 / Shift+ホイール=回転 / Delete=削除 / [ / ]=奥/手前
        </div>
</div>
</main>
</div>
<!-- Parts Management View -->
<section class="parts-manage hidden" id="viewParts">
<div class="toolbar">
<input class="input" id="pmSearch" placeholder="パーツ名で検索" style="flex:1; min-width:200px;"/> <select class="select" id="pmColorSel"><option value="">色・花材</option></select> <select class="select" id="pmSizeSel"><option value="">サイズ</option><option value="S">S</option><option value="M">M</option><option value="L">L</option><option value="XL">XL</option></select> <button class="btn" id="pmFilterClear">抽出クリア</button>
<button class="btn" id="pmAddBtn">パーツ追加</button>
<button class="btn" id="pmFolderBtn">フォルダ取り込み</button>
<button class="btn" id="pmExportBtn">ライブラリ書き出し</button>
<button class="btn" id="pmImportBtn">ライブラリ読込</button>
</div>
<div class="pm-grid" id="pmGrid"></div>
</section>
<!-- Background Management View -->
<section class="bg-manage hidden" id="viewBackgrounds">
<div class="toolbar">
<input class="input" id="bgSearch" placeholder="背景名で検索" style="flex:1; min-width:200px;"/>
<button class="btn" id="bgAddBtn">背景追加</button>
<button class="btn" id="bgFolderBtn">フォルダ取り込み</button>
<button class="btn" id="bgExportBtn">ライブラリ書き出し</button>
<button class="btn" id="bgImportBtn">ライブラリ読込</button>
</div>
<div class="bg-grid" id="bgGrid"></div>
</section>
<script nonce="R4nd0mN0nc3">
/* === IndexedDB === */
const DB_NAME = 'funeralComposerDB';
const DB_VER  = 2;
let dbPromise = null;
function openDB(){
  if (dbPromise) return dbPromise;
  dbPromise = new Promise((resolve, reject)=>{
    const req = indexedDB.open(DB_NAME, DB_VER);
    req.onupgradeneeded = (e)=>{
      const db = req.result;
      if (!db.objectStoreNames.contains('backgrounds')) db.createObjectStore('backgrounds', { keyPath: 'id' });
      if (!db.objectStoreNames.contains('parts'))       db.createObjectStore('parts',       { keyPath: 'id' });
      if (!db.objectStoreNames.contains('templates'))  db.createObjectStore('templates',  { keyPath: 'id' });
    };
    req.onsuccess = ()=> resolve(req.result);
    req.onerror = ()=> reject(req.error);
  });
  return dbPromise;
}
function idbPut(store, value){
  return openDB().then(db => new Promise((resolve, reject)=>{
    const tx = db.transaction(store, 'readwrite');
    tx.objectStore(store).put(value);
    tx.oncomplete = ()=> resolve(true);
    tx.onerror = ()=> reject(tx.error);
  }));
}
function idbGetAll(store){
  return openDB().then(db => new Promise((resolve, reject)=>{
    const tx = db.transaction(store, 'readonly');
    const req = tx.objectStore(store).getAll();
    req.onsuccess = ()=> resolve(req.result || []);
    req.onerror = ()=> reject(req.error);
  }));
}
// Added: idbGet for single record lookup (used by importFromManifest)
function idbGet(store, id){
  return openDB().then(db => new Promise((resolve, reject)=>{
    try{
      const tx = db.transaction(store, 'readonly');
      const req = tx.objectStore(store).get(id);
      req.onsuccess = ()=> resolve(req.result || null);
      req.onerror = ()=> reject(req.error || new Error('idbGet failed'));
    }catch(err){
      reject(err);
    }
  }));
}
function idbDelete(store, id){
  return openDB().then(db => new Promise((resolve, reject)=>{
    const tx = db.transaction(store, 'readwrite');
    tx.objectStore(store).delete(id);
    tx.oncomplete = ()=> resolve(true);
    tx.onerror = ()=> reject(tx.error);
  }));
}





// Count how many times the "追加" button was clicked per part
async function incrementPartAddCount(partId){
  try{
    const rec = await idbGet('parts', partId);
    if(rec){
      const newCount = (rec.addCount|0) + 1;
      await idbPut('parts', { ...rec, addCount: newCount });
      // update runtime state
      const idx = state.parts.findIndex(x=>x.id===partId);
      if(idx>=0){ state.parts[idx].addCount = newCount; }
    }
  }catch(err){
    console.error('incrementPartAddCount failed', err);
  }
}


// --- AddCount reset helpers ---
async function resetPartAddCount(partId){
  try{
    const rec = await idbGet('parts', partId);
    if(rec){
      await idbPut('parts', { ...rec, addCount: 0 });
      const idx = state.parts.findIndex(x=>x.id===partId);
      if(idx>=0){ state.parts[idx].addCount = 0; }
      // If parts-manage is visible, re-render to reflect change
      if (document.getElementById('parts-manage-root')) {
        renderPartsManage();
      }
    }
  }catch(err){
    console.error('resetPartAddCount failed', err);
  }
}

async function resetAllAddCounts(){
  try{
    const parts = await idbGetAll('parts');
    for(const m of parts){
      await idbPut('parts', { ...m, addCount: 0 });
    }
    state.parts.forEach(p=>p.addCount=0);
    if (document.getElementById('parts-manage-root')) {
      renderPartsManage();
    }
  }catch(err){
    console.error('resetAllAddCounts failed', err);
  }
}
// --- End AddCount reset helpers ---

function TrueFix(){ return true; }
// ------- State -------
let __dropGuard = false;
const state = {
  backgrounds: [], // {id,title,img,w,h}
  parts: [],       // {id,name,img,w,h}
  layers: [],      // {id,partId,x,y,scale,rot,z}
  templates: [],   // {id,name,bgId,layers,createdAt}
  bgId: "",
  zoom: 1
};

const uid = () => Math.random().toString(36).slice(2,10);
const clamp = (v,a,b)=>Math.max(a, Math.min(b,v));

// ------- DOM -------
const bgSelect = document.getElementById('bgSelect');
const bgInput  = document.getElementById('bgInput');
const partInput= document.getElementById('partInput');
const partsEl  = document.getElementById('parts');
const filterColorSel = document.getElementById('filterColorSel');
const filterSize  = document.getElementById('filterSize');
const filterClear = document.getElementById('filterClear');
function updateColorFilterOptions(){
  if(!filterColorSel) return;
  const colors = Array.from(new Set([].concat(...(state.parts||[]).map(p=> String(p.color||'').split(/[,、\s]+/).map(s=>s.trim()).filter(Boolean))))).sort((a,b)=>a.localeCompare(b));
  const cur = filterColorSel.value || '';
  filterColorSel.innerHTML = '<option value="">色・花材</option>' + colors.map(c=>`<option value="${c}">${c}</option>`).join('');
  if(colors.includes(cur)) filterColorSel.value = cur; else filterColorSel.value = '';
}
[filterColorSel, filterSize].forEach(el=> el?.addEventListener('input', ()=> renderParts()));
filterClear?.addEventListener('click', ()=>{ if(filterColorSel) filterColorSel.value=''; if(filterSize) filterSize.value=''; renderParts();
  updateColorFilterOptions?.();
  updatePMColorOptions?.(); });
const zoomOut  = document.getElementById('zoomOut');
const zoomIn   = document.getElementById('zoomIn');
const zoomPct  = document.getElementById('zoomPct');
const exportBtn= document.getElementById('exportBtn');
const tplSaveBtn = document.getElementById('tplSaveBtn');
const tplSelect  = document.getElementById('tplSelect');
const tplDeleteBtn = document.getElementById('tplDeleteBtn');
const resetBtn   = document.getElementById('resetBtn');
const cvs = document.getElementById('cvs');
const ctx = cvs.getContext('2d');

// ====== Tabs & Parts Management ======
const tabCompose = document.getElementById('tabCompose');
const tabParts   = document.getElementById('tabParts');
const tabBackgrounds = document.getElementById('tabBackgrounds');
const viewParts  = document.getElementById('viewParts');
const viewBackgrounds = document.getElementById('viewBackgrounds');
const layoutMain = document.querySelector('.layout');

function showCompose(){
  tabCompose.classList.add('active');
  tabParts.classList.remove('active');
  tabBackgrounds?.classList.remove('active');
  layoutMain.classList.remove('hidden');
  viewParts.classList.add('hidden');
  viewBackgrounds.classList.add('hidden');
}
function showParts(){
  tabParts.classList.add('active');
  tabCompose.classList.remove('active');
  tabBackgrounds?.classList.remove('active');
  layoutMain.classList.add('hidden');
  viewParts.classList.remove('hidden');
  viewBackgrounds.classList.add('hidden');
  if (typeof renderPartsManage === 'function') { renderPartsManage(); } else { setTimeout(()=> renderPartsManage?.(), 0); }
}
function showBackgrounds(){
  tabBackgrounds?.classList.add('active');
  tabCompose.classList.remove('active');
  tabParts.classList.remove('active');
  layoutMain.classList.add('hidden');
  viewParts.classList.add('hidden');
  viewBackgrounds.classList.remove('hidden');
  renderBackgroundsManage();
}

tabCompose?.addEventListener('click', showCompose);
tabParts?.addEventListener('click', showParts);
tabBackgrounds?.addEventListener('click', showBackgrounds);

// Parts management operations
const pmGrid = document.getElementById('pmGrid');
const pmSearch = document.getElementById('pmSearch');
const pmColorSel = document.getElementById('pmColorSel');
const pmSizeSel  = document.getElementById('pmSizeSel');
const pmFilterClear = document.getElementById('pmFilterClear');
const pmAddBtn = document.getElementById('pmAddBtn');
const pmFolderBtn = document.getElementById('pmFolderBtn');
const pmExportBtn = document.getElementById('pmExportBtn');
const pmImportBtn = document.getElementById('pmImportBtn');

pmAddBtn?.addEventListener('click', ()=> partInput?.click());
pmFolderBtn?.addEventListener('click', ()=> folderBtn?.click());
pmExportBtn?.addEventListener('click', ()=> libExportBtn?.click());
pmImportBtn?.addEventListener('click', ()=> libImportBtn?.click());

pmSearch?.addEventListener('input', ()=> renderPartsManage(pmSearch.value.trim()));

function updatePMColorOptions(){
  if(!pmColorSel) return;
  const colors = Array.from(new Set([].concat(...(state.parts||[]).map(p=> String(p.color||'').split(/[,、\s]+/).map(s=>s.trim()).filter(Boolean))))).sort((a,b)=>a.localeCompare(b));
  const cur = pmColorSel.value || '';
  pmColorSel.innerHTML = '<option value=\"\">色・花材</option>' + colors.map(c=>`<option value=\"${c}\">${c}</option>`).join('');
  if(colors.includes(cur)) pmColorSel.value = cur; else pmColorSel.value = '';
}
pmColorSel?.addEventListener('input', ()=> renderPartsManage(pmSearch.value.trim()));
pmSizeSel?.addEventListener('input',  ()=> renderPartsManage(pmSearch.value.trim()));
pmFilterClear?.addEventListener('click', ()=>{ if(pmColorSel) pmColorSel.value=''; if(pmSizeSel) pmSizeSel.value=''; renderPartsManage(pmSearch.value.trim()); });



async function renderPartsManage(query=""){
  try {
    const list = await idbGetAll('parts');
    const items = [];
    for(const m of list){
      const objUrl = URL.createObjectURL(m.blob);
      items.push({ id:m.id, name:m.name, w:m.w, h:m.h, createdAt:m.createdAt||0, url:objUrl, color: m.color || '', size: m.size || '', addCount: (m.addCount||0) });
    }
    const filteredByName = query ? items.filter(x => (x.name||"").toLowerCase().includes(query.toLowerCase())) : items;
    const c = (pmColorSel?.value || '').toLowerCase().trim();
    const sz = (pmSizeSel?.value || '').toUpperCase().trim();
    const filtered = filteredByName.filter(x=>{
      const okC = c ? String(x.color||'').toLowerCase().includes(c) : true;
      const okS = sz ? String(x.size||'').toUpperCase()===sz : true;
      return okC && okS;
    });
    pmGrid.innerHTML = "";
    if(filtered.length === 0){
      pmGrid.innerHTML = `<div style="color:#6b7280;">該当するパーツがありません</div>`;
      return;
    }
    for(const p of filtered){
      const card = document.createElement('div');
      card.className = "pm-card";
      card.innerHTML = `
        <div class="pm-thumb"><img src="${p.url}" alt=""></div>
        <div class="pm-body">
          <div class="pm-name" title="${p.name}">${p.name}</div>
          <div class="pm-meta">${p.w}×${p.h}px ${p.createdAt ? `・登録: ${new Date(p.createdAt).toLocaleString()}` : ''} ・追加: ${p.addCount||0}回</div>
          <div class="pm-colors">色: ${String(p.color||"").split(/[,、\s]+/).filter(Boolean).map(c=>`<span class="chip">${c}</span>`).join(" ")}</div>
          <div class="pm-field">
            <label>色・花材</label>
            <input type="text" value="${p.color||''}" placeholder="例: 白, 赤, 青" data-field="color" style="width:14em">
            <label>サイズ</label>
            <select data-field="size">
              <option value="">未設定</option>
              <option value="S">S</option>
              <option value="M">M</option>
              <option value="L">L</option>
              <option value="XL">XL</option>
            </select>
          </div>
          <div class="pm-actions">
            <button class="btn" data-action="rename">名前変更</button>
            <button class="btn" data-action="delete">削除</button>
            <button class="btn pm-reset" data-id="${p.id}">回数リセット</button>
          </div>
        </div>
      `;
// Rename
      card.querySelector('[data-action="rename"]').addEventListener('click', async (e)=>{
        e.preventDefault(); e.stopPropagation();
        const newName = prompt('新しい名前を入力', p.name||'');
        if(!newName || newName===p.name) return;
        try{
          const all = await idbGetAll('parts');
          const hit = all.find(x=>x.id===p.id);
          if(hit){
            await idbPut('parts', { ...hit, name:newName });
            // runtime state も更新
            const idx = state.parts.findIndex(x=>x.id===p.id);
            if(idx>=0){ state.parts[idx].name = newName; renderParts(); }
            renderPartsManage(pmSearch.value.trim());
          }
        }catch(err){ alert('名前変更に失敗しました'); console.error(err); }
      });
      // Delete
      card.querySelector('[data-action="delete"]').addEventListener('click', async (e)=>{
        e.preventDefault(); e.stopPropagation();
        if(!confirm('このパーツを削除しますか？')) return;
        try{
          await idbDelete('parts', p.id);
          // runtime state からも除去
          const idx = state.parts.findIndex(x=>x.id===p.id);
          if(idx>=0){ state.parts.splice(idx,1); renderParts(); }
          renderPartsManage(pmSearch.value.trim());
        }catch(err){ alert('削除に失敗しました'); console.error(err); }
      });

      // set size initial value
      const sizeSel = card.querySelector('select[data-field="size"]');
      if(sizeSel){ sizeSel.value = (p.size||''); }
      // change handlers
      const colorInput = card.querySelector('input[data-field="color"]');
      function saveFields(){
        (async ()=>{
          try{
            const all = await idbGetAll('parts');
            const hit = all.find(x=>x.id===p.id);
            if(hit){
              const newColor = colorInput?.value || '';
              const newSize  = sizeSel?.value || '';
              await idbPut('parts', { ...hit, color:newColor, size:newSize });
              // update runtime state
              const idx = state.parts.findIndex(x=>x.id===p.id);
              if(idx>=0){
                state.parts[idx].color = newColor;
                state.parts[idx].size  = newSize;
                renderParts();
                updateColorFilterOptions?.();
                updatePMColorOptions?.();
              }
            }
          }catch(err){ console.error('保存に失敗しました', err); alert('保存に失敗しました'); }
        })();
      }
      colorInput?.addEventListener('change', saveFields);
      sizeSel?.addEventListener('change', saveFields);

      pmGrid.appendChild(card);
    }
  } catch (e) {
    console.error(e);
    pmGrid.innerHTML = `<div style="color:#ef4444;">読み込みに失敗しました</div>`;
  }
}
// Background management operations
const bgGrid = document.getElementById('bgGrid');
const bgSearch = document.getElementById('bgSearch');
const bgAddBtn = document.getElementById('bgAddBtn');
const bgFolderBtn = document.getElementById('bgFolderBtn');
const bgExportBtn = document.getElementById('bgExportBtn');
const bgImportBtn = document.getElementById('bgImportBtn');

bgAddBtn?.addEventListener('click', ()=> bgInput?.click());
bgFolderBtn?.addEventListener('click', ()=> folderBtn?.click());
bgExportBtn?.addEventListener('click', ()=> libExportBtn?.click());
bgImportBtn?.addEventListener('click', ()=> libImportBtn?.click());

bgSearch?.addEventListener('input', ()=> renderBackgroundsManage(bgSearch.value.trim()));


async function renderBackgroundsManage(query=""){
  try{
    const list = await idbGetAll('backgrounds');
    const items = [];
    for(const b of list){
      const objUrl = URL.createObjectURL(b.blob);
      items.push({ id:b.id, title:b.title, w:b.w, h:b.h, createdAt:b.createdAt||0, url:objUrl });
    }
    const filtered = query ? items.filter(x => (x.title||"").toLowerCase().includes(query.toLowerCase())) : items;
    bgGrid.innerHTML = "";
    if(filtered.length === 0){
      bgGrid.innerHTML = `<div style="color:#6b7280;">該当する背景がありません</div>`;
      return;
    }
    for(const bg of filtered){
      const card = document.createElement('div');
      card.className = "bg-card";
      card.innerHTML = `
        <div class="pm-thumb"><img src="${bg.url}" alt=""></div>
        <div class="pm-body">
          <div class="pm-name" title="${bg.title||''}">${bg.title||'(無題)'}</div>
          <div class="pm-meta">${bg.w}×${bg.h}px ${bg.createdAt ? `・登録: ${new Date(bg.createdAt).toLocaleString()}` : ''}</div>
          <div class="pm-actions">
            <button class="btn" data-action="rename">名前変更</button>
            <button class="btn" data-action="delete">削除</button>
          </div>
        </div>
        `;
// Rename
      card.querySelector('[data-action="rename"]').addEventListener('click', async ()=>{
        const newTitle = prompt('新しい名前を入力', bg.title||'');
        if(!newTitle || newTitle===bg.title) return;
        try{
          const all = await idbGetAll('backgrounds');
          const hit = all.find(x=>x.id===bg.id);
          if(hit){
            await idbPut('backgrounds', { ...hit, title:newTitle });
            // runtime state 更新
            const idx = state.backgrounds.findIndex(x=>x.id===bg.id);
            if(idx>=0){ state.backgrounds[idx].title = newTitle; renderBgSelect(); }
            renderBackgroundsManage(bgSearch.value.trim());
          }
        }catch(err){ alert('名前変更に失敗しました'); console.error(err); }
      });
      // Delete
      card.querySelector('[data-action="delete"]').addEventListener('click', async ()=>{
        if(!confirm('この背景を削除しますか？')) return;
        try{
          await idbDelete('backgrounds', bg.id);
          // runtime state からも除去
          const idx = state.backgrounds.findIndex(x=>x.id===bg.id);
          if(idx>=0){
            state.backgrounds.splice(idx,1);
            // 現在選択中の背景が消えた場合のフォールバック
            if(state.bgId === bg.id){
              state.bgId = state.backgrounds[0]?.id || "";
              localStorage.setItem('bgId', state.bgId);
            }
            renderBgSelect();
            draw();
          }
          renderBackgroundsManage(bgSearch.value.trim());
        }catch(err){ alert('削除に失敗しました'); console.error(err); }
      });
      bgGrid.appendChild(card);
    }
  }catch(e){
    console.error(e);
    bgGrid.innerHTML = `<div style="color:#ef4444;">読み込みに失敗しました</div>`;
  }
}

// ------- Image helpers -------
function fileToURL(file){
  return new Promise((res,rej)=>{
    const r = new FileReader();
    r.onload = ()=>res(r.result);
    r.onerror = rej;
    r.readAsDataURL(file);
  });
}

function imgFromURL(url){
  return new Promise((res)=>{
    const img = new Image();
    img.onload = ()=>res(img);
    img.src = url;
  });
}

// ------- UI helpers -------
function renderBgSelect(){
  bgSelect.innerHTML = "";
  if(state.backgrounds.length===0){
    const opt = document.createElement('option');
    opt.value = ""; opt.textContent = "背景なし";
    bgSelect.appendChild(opt);
  }
  state.backgrounds.forEach(b=>{
    const opt = document.createElement('option');
    opt.value = b.id; opt.textContent = b.title;
    bgSelect.appendChild(opt);
  });
  if(state.bgId){
    bgSelect.value = state.bgId;
  }
}

function renderParts(){
  partsEl.innerHTML = "";
  if(state.parts.length===0){
    const d = document.createElement('div');
    d.className = "hint";
    d.textContent = "透過PNGのパーツを追加してください。";
    partsEl.appendChild(d);
  } else {
    const c = (document.getElementById('filterColorSel')?.value || '').toLowerCase().trim();
    const s = (document.getElementById('filterSize')?.value || '').toUpperCase().trim();
    const partsFiltered = state.parts.filter(p=>{
      const okColor = c ? (String(p.color||'').toLowerCase().includes(c)) : true;
      const okSize  = s ? (String(p.size||'').toUpperCase()===s) : true;
      return okColor && okSize;
    });
    partsFiltered.forEach(p=>{
      // Container card (div) to allow nested button
      const card = document.createElement('div');
      card.className = "part";
      card.innerHTML = `
        <div class="thumb"><img src="${p.url}"></div>
        <div class="name">${p.name}</div>
        <div style="color:#6b7280; font-size:.75rem;">${p.w}×${p.h}px</div>
      `;
      // Tap-friendly add button (works on mobile without drag & drop)
      const addBtn = document.createElement('button');
      addBtn.className = "btn add";
      addBtn.textContent = "追加";
      addBtn.addEventListener('click', async (e)=>{
        e.preventDefault(); e.stopPropagation();
        addLayerFromPart(p.id, {skipInc:true});
        await incrementPartAddCount(p.id);
      });
      card.appendChild(addBtn);

      // Keep drag support on desktop
      // draggable disabled by request
// dragstart handler removed
partsEl.appendChild(card);
    });
  }
}

function setZoom(z){
  state.zoom = clamp(z, 0.2, 4);
  zoomPct.textContent = Math.round(state.zoom*100)+"%";
  draw();
}

zoomOut.onclick = ()=> setZoom(state.zoom*0.9);
zoomIn.onclick  = ()=> setZoom(state.zoom*1.1);

// ------- Background & parts upload -------
bgInput.onchange = async (e)=>{
  const f = e.target.files && e.target.files[0];
  if(!f) return;
  const url = await fileToURL(f);
  const img = await imgFromURL(url);
  const id = uid();
  const rec = { id, title: f.name.replace(/\.[^.]+$/, ''), w: img.naturalWidth, h: img.naturalHeight, createdAt: Date.now() };
  await idbPut('backgrounds', { ...rec, blob: f });
  const objUrl = URL.createObjectURL(f);
  const b = { ...rec, img: await imgFromURL(objUrl), url: objUrl };
  state.backgrounds.unshift(b);
  state.bgId = b.id;
  localStorage.setItem('bgId', state.bgId);
  
  // If empty on first run, seed sample assets
  const firstRunKey = 'seededSamplesV1';
  const seeded = localStorage.getItem(firstRunKey) === '1';
  if (!seeded) {
    if (state.backgrounds.length === 0 && SAMPLE_ASSETS.backgrounds.length){
      for (const s of SAMPLE_ASSETS.backgrounds){
        const res = await fetch(s.dataUrl);
        const blob = await res.blob();
        const img = await imgFromURL(s.dataUrl);
        const id = uid();
        await idbPut('backgrounds', { id, title: s.title, w: img.naturalWidth||800, h: img.naturalHeight||600, blob, createdAt: Date.now() });
      }
    }
    if (state.parts.length === 0 && SAMPLE_ASSETS.parts.length){
      for (const s of SAMPLE_ASSETS.parts){
        const res = await fetch(s.dataUrl);
        const blob = await res.blob();
        const img = await imgFromURL(s.dataUrl);
        const id = uid();
        await idbPut('parts', { id, name: s.name, w: img.naturalWidth||100, h: img.naturalHeight||100, blob, createdAt: Date.now() , addCount: 0 });
      }
    }
    localStorage.setItem(firstRunKey, '1');
    return initFromDB(); // reload
  }
  renderBgSelect();
  draw();
};

partInput.onchange = async (e)=>{
  const f = e.target.files && e.target.files[0];
  if(!f) return;
  const url = await fileToURL(f);
  const img = await imgFromURL(url);
  const id = uid();
  const rec = { id, name: f.name.replace(/\.[^.]+$/, ''), w: img.naturalWidth, h: img.naturalHeight, createdAt: Date.now(), color:'', size:'' };
  await idbPut('parts', { ...rec, blob: f });
  const objUrl = URL.createObjectURL(f);
  const p = { ...rec, img: await imgFromURL(objUrl), url: objUrl, color:'', size:'' };
  state.parts.unshift(p);
  renderParts();
};

bgSelect.onchange = ()=>{
  state.bgId = bgSelect.value;
  localStorage.setItem('bgId', state.bgId);
  draw();
};

function currentBg(){
  return state.backgrounds.find(b=>b.id===state.bgId) || state.backgrounds[0] || null;
}

async function addLayerFromPartAt(partId, x, y){
  const bg = currentBg(); if(!bg) return;
  const p = state.parts.find(xp=>xp.id===partId); if(!p) return;
  const L = {
    id: uid(), partId: p.id,
    x: (x!=null? x : bg.w/2),
    y: (y!=null? y : bg.h*0.65),
    scale: Math.min(1, (bg.w*0.3)/p.w),
    rot: 0, flipX: false, z: (state.layers.length? Math.max(...state.layers.map(l=>l.z||0))+1: 1)
  };
  state.layers.push(L);
  selectedId = L.id;
  draw();
}
async function addLayerFromPart(partId, opts = {}){
  const bg = currentBg(); if(!bg) return;
  const p = state.parts.find(x=>x.id===partId); if(!p) return;
  const L = {
    id: uid(), partId: p.id,
    x: bg.w/2, y: bg.h*0.65,
    scale: Math.min(1, (bg.w*0.3)/p.w),
    rot: 0, flipX: false, z: (state.layers.length? Math.max(...state.layers.map(l=>l.z||0))+1: 1)
  };
  state.layers.push(L);
  
      try{ if(!(opts&&opts.skipInc)){ await incrementPartAddCount(partId); } }catch(e){ console.warn('increment addCount (drag) failed', e); }
selectedId = L.id;
  draw();
}

// ------- Drawing -------
let selectedId = "";
const HANDLE_R = 12;

function draw(){
  const bg = currentBg();
  const width  = bg? bg.w : 1920;
  const height = bg? bg.h : 1080;
  cvs.width = width; cvs.height = height;
  const stage = document.getElementById('stage');
  stage.style.width = (width*state.zoom) + "px";
  stage.style.height= (height*state.zoom)+ "px";
  cvs.style.transform = `scale(${state.zoom})`;
  cvs.style.transformOrigin = "top left";
  cvs.style.touchAction = "none";

  ctx.clearRect(0,0,width,height);

  if(bg){
    ctx.drawImage(bg.img, 0, 0, width, height);
  }else{
    ctx.fillStyle = "#f2f2f2"; ctx.fillRect(0,0,width,height);
    ctx.fillStyle = "#bbb"; ctx.fillRect(0, height-60, width, 60);
  }

  // draw layers
  const sorted = [...state.layers].sort((a,b)=>(a.z??0)-(b.z??0));
  for(const L of sorted){
    const p = state.parts.find(pp=>pp.id===L.partId); if(!p) continue;
    const w = p.w * (L.scale||1), h = p.h * (L.scale||1);
    ctx.save();
    ctx.translate(L.x, L.y);
    ctx.rotate(((L.rot||0)*Math.PI)/180);
    if (L.flipX) ctx.scale(-1, 1);
    ctx.drawImage(p.img, -w/2, -h/2, w, h);
    ctx.restore();
  }

  // selection and handles
  const sel = state.layers.find(l=>l.id===selectedId);
  if(sel){
    const p = state.parts.find(pp=>pp.id===sel.partId);
    if(p){
      const w = p.w*(sel.scale||1), h = p.h*(sel.scale||1);
      const ang = ((sel.rot||0)*Math.PI)/180;
      const cx = sel.x, cy = sel.y;
      const corners = [
        {x:-w/2, y:-h/2}, {x:w/2, y:-h/2}, {x:w/2, y:h/2}, {x:-w/2, y:h/2}
      ].map(pt=>({ x: cx + pt.x*Math.cos(ang) - pt.y*Math.sin(ang),
                   y: cy + pt.x*Math.sin(ang) + pt.y*Math.cos(ang) }));

      ctx.save();
      ctx.setLineDash([6,4]); ctx.strokeStyle = "#3b82f6"; ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(corners[0].x, corners[0].y);
      for(let i=1;i<4;i++) ctx.lineTo(corners[i].x, corners[i].y);
      ctx.closePath(); ctx.stroke(); ctx.setLineDash([]);
      for(const c of corners){
        ctx.fillStyle="#fff"; ctx.strokeStyle="#3b82f6"; ctx.lineWidth=2;
        ctx.beginPath(); ctx.arc(c.x,c.y,6,0,Math.PI*2); ctx.fill(); ctx.stroke();
      }
      ctx.restore();
    }
  }
}

// ------- Hit test helpers -------
function pointInRotRect(rx, ry, L, p){
  const w = p.w * (L.scale||1), h = p.h * (L.scale||1);
  const ang = ((L.rot||0)*Math.PI)/180;
  const dx = rx - L.x, dy = ry - L.y;
  const lx =  dx*Math.cos(-ang) - dy*Math.sin(-ang);
  const ly =  dx*Math.sin(-ang) + dy*Math.cos(-ang);
  return (Math.abs(lx) <= w/2) && (Math.abs(ly) <= h/2);
}

// Overlap cycle state for canvas
let __cycle = { key: "", index: 0, ids: [] };
let __lastClick = { x: 0, y: 0, t: 0 };
function __cycleKey(rx, ry){ const q = (v)=> Math.round(v/8); return q(rx)+":"+q(ry); }
function hitLayersAt(rx, ry){
  const top = [...state.layers].sort((a,b)=>(b.z??0)-(a.z??0));
  const hits = [];
  for(const L of top){
    const p = state.parts.find(pp=>pp.id===L.partId); if(!p) continue;
    if(pointInRotRect(rx, ry, L, p)) hits.push(L);
  }
  return hits; // z降順
}
function hitLayer(rx, ry){
  const top = [...state.layers].sort((a,b)=>(b.z??0)-(a.z??0));
  for(const L of top){
    const p = state.parts.find(pp=>pp.id===L.partId); if(!p) continue;
    if(pointInRotRect(rx, ry, L, p)) return L;
  }
  return null;
}

function layerCorners(sel, p){
  const w = p.w*(sel.scale||1), h = p.h*(sel.scale||1);
  const ang = ((sel.rot||0)*Math.PI)/180;
  const cx = sel.x, cy = sel.y;
  const raw = [{x:-w/2,y:-h/2},{x:w/2,y:-h/2},{x:w/2,y:h/2},{x:-w/2,y:h/2}];
  return raw.map(pt=>({ x: cx + pt.x*Math.cos(ang) - pt.y*Math.sin(ang),
                        y: cy + pt.x*Math.sin(ang) + pt.y*Math.cos(ang) }));
}

// ------- Pointer & wheel -------
function hitHandle(rx, ry){
  const top = [...state.layers].sort((a,b)=>(b.z??0)-(a.z??0));
  for(const L of top){
    const p = state.parts.find(pp=>pp.id===L.partId); if(!p) continue;
    const corners = layerCorners(L, p);
    for(let i=0;i<4;i++){
      const c = corners[i];
      if(Math.hypot(rx - c.x, ry - c.y) <= HANDLE_R){
        return { layer: L, cornerIndex: i };
      }
    }
  }
  return null;
}

let drag = null; // {mode, id, ox, oy} | {mode:'resize', id, startScale, startDist}

function canvasXY(evt){
  const rect = cvs.getBoundingClientRect();
  const rx = (evt.clientX - rect.left) * (cvs.width / rect.width);
  const ry = (evt.clientY - rect.top) * (cvs.height / rect.height);
  return {x:rx, y:ry};
}

cvs.addEventListener('pointerdown', (e)=>{
  const {x:rx, y:ry} = canvasXY(e);

  // 1) handle (corner) has top priority -> start resize
  const hh = hitHandle(rx, ry);
  if(hh){
    const hit = hh.layer;
    selectedId = hit.id;
    const startDist = Math.hypot(rx - hit.x, ry - hit.y);
    drag = { mode:'resize', id: hit.id, startScale: hit.scale||1, startDist: Math.max(1, startDist) };
    try { cvs.setPointerCapture && cvs.setPointerCapture(e.pointerId); } catch {}
    draw();
    return;
  }

  // 2) otherwise move: ALWAYS pick the top-most hit under the pointer
  const hits = hitLayersAt(rx, ry);
  if(hits.length){
    const sel = hits[0]; // pick the foremost
    selectedId = sel.id;
    drag = { mode:'move', id: sel.id, ox: rx - sel.x, oy: ry - sel.y };
  } else {
    selectedId = "";
    drag = null;
  }
  try { cvs.setPointerCapture && cvs.setPointerCapture(e.pointerId); } catch {}
  draw();
});

cvs.addEventListener('pointermove', (e)=>{
  if(!drag) return;
  const {x:rx, y:ry} = canvasXY(e);
  const idx = state.layers.findIndex(l=>l.id===drag.id);
  if(idx<0) return;
  const L = state.layers[idx];
  if(drag.mode==='move'){
    L.x = rx - drag.ox; L.y = ry - drag.oy;
  }else if(drag.mode==='resize'){
    const currentDist = Math.hypot(rx - L.x, ry - L.y);
    L.scale = clamp((currentDist / drag.startDist) * drag.startScale, 0.05, 5);
  }
  draw();
});

cvs.addEventListener('pointerup', (e)=>{ drag = null; try { cvs.releasePointerCapture && cvs.releasePointerCapture(e.pointerId); } catch {} });
cvs.addEventListener('pointerleave', (e)=>{ drag = null; try { cvs.releasePointerCapture && cvs.releasePointerCapture(e.pointerId); } catch {} });

// wheel (passive:false) for scale/rotate on selected
cvs.addEventListener('wheel', (e)=>{
  if(!selectedId) return;
  e.preventDefault(); // <- requires passive:false (default in addEventListener without options in most browsers is passive:false for wheel)
  const idx = state.layers.findIndex(l=>l.id===selectedId); if(idx<0) return;
  const L = state.layers[idx];
  if(e.shiftKey){
    L.rot = Math.round(((L.rot||0) - Math.sign(e.deltaY)*2 + 360) % 360);
  }else{
    L.scale = clamp((L.scale||1) * (1 - e.deltaY*0.001), 0.05, 5);
  }
  draw();
}, { passive:false });



// --- Flip & Duplicate ---
const flipBtn = document.getElementById('flipBtn');
const dupBtn  = document.getElementById('dupBtn');

const layerUpBtn   = document.getElementById('layerUpBtn');
const layerDownBtn = document.getElementById('layerDownBtn');

function moveLayerStep(dir){
  if(!selectedId) return;
  // 作図順（zの小さい方が奥、同仕様を前提）で並べ替え
  const ordered = [...state.layers].sort((a,b)=> (a.z||0) - (b.z||0));
  const i = ordered.findIndex(l => l.id === selectedId);
  if(i < 0) return;
  const j = i + (dir > 0 ? 1 : -1);
  if(j < 0 || j >= ordered.length) return; // 端では何もしない
  // となりの要素と z 値をスワップして相対順を入れ替える
  const sel = ordered[i];
  const nb  = ordered[j];
  const tmp = sel.z || 0;
  sel.z = nb.z || 0;
  nb.z  = tmp;
  draw();
}
function flipSelected(){
  if(!selectedId) return;
  const L = state.layers.find(l=>l.id===selectedId); if(!L) return;
  L.flipX = !L.flipX;
  draw();
}
function duplicateSelected(){
  if(!selectedId) return;
  const src = state.layers.find(l=>l.id===selectedId); if(!src) return;
  const copy = { ...src, id: uid(), x: src.x + 20, y: src.y + 20, z: (src.z||0)+1 };
  state.layers.push(copy);
  selectedId = copy.id;
  draw();
}

flipBtn.onclick = flipSelected;
dupBtn.onclick  = duplicateSelected;

layerUpBtn.onclick   = ()=> moveLayerStep(+1);
layerDownBtn.onclick = ()=> moveLayerStep(-1);
// Shortcuts: H=flip, D=duplicate
window.addEventListener('keydown', (e)=>{
  if (e.key === 'h' || e.key === 'H') { flipSelected(); }
  if (e.key === 'd' || e.key === 'D') { duplicateSelected(); }
});


// ===== Pinch-to-scale (touch) =====
const activePointers = new Map(); // id -> {x,y}
let pinchState = null; // {id1,id2,startDist,startScale}

function updatePointer(e){
  const {x, y} = canvasXY(e);
  activePointers.set(e.pointerId, {x, y});
}

function currentTwoPointers(){
  const ids = Array.from(activePointers.keys());
  if (ids.length < 2) return null;
  return [ids[0], ids[1]];
}

function distOf(a,b){ return Math.hypot(a.x - b.x, a.y - b.y); }

cvs.addEventListener('pointerdown', (e)=>{
  if (e.pointerType === 'touch') {
    updatePointer(e);
    // if two fingers now and we have a selection, start pinch
    const pair = currentTwoPointers();
    if (pair && selectedId){
      const A = activePointers.get(pair[0]), B = activePointers.get(pair[1]);
      pinchState = { id1: pair[0], id2: pair[1], startDist: Math.max(1, distOf(A,B)) };
      const L = state.layers.find(l=>l.id===selectedId);
      pinchState.startScale = L ? (L.scale || 1) : 1;
      try { cvs.setPointerCapture && cvs.setPointerCapture(e.pointerId); } catch {}
    }
  }
}, { passive:false });

cvs.addEventListener('pointermove', (e)=>{
  if (e.pointerType === 'touch') {
    updatePointer(e);
    if (pinchState && selectedId){
      const A = activePointers.get(pinchState.id1);
      const B = activePointers.get(pinchState.id2);
      if (A && B){
        e.preventDefault();
        const L = state.layers.find(l=>l.id===selectedId);
        if (L){
          const d = Math.max(1, distOf(A,B));
          L.scale = clamp((d / pinchState.startDist) * pinchState.startScale, 0.05, 5);
          draw();
        }
      }
    }
  }
}, { passive:false });

function endPointer(e){
  activePointers.delete(e.pointerId);
  if (pinchState && (e.pointerId === pinchState.id1 || e.pointerId === pinchState.id2)){
    pinchState = null;
  }
}

cvs.addEventListener('pointerup', endPointer);
cvs.addEventListener('pointercancel', endPointer);


// ===== Folder Import (manual local assets) =====
const folderBtn = document.getElementById('folderBtn');
const folderInput = document.getElementById('folderInput');
folderBtn.onclick = ()=> folderInput.click();

function classifyPath(path){
  const p = path.toLowerCase();
  if (p.includes('/background') || p.includes('\\background') || p.includes('/bg/') || p.includes('\\bg\\') || p.includes('/backgrounds/') || p.includes('\\backgrounds\\')) return 'background';
  return 'part';
}

async function importFolderFiles(fileList){
  const files = Array.from(fileList || [])
    .filter(f => f.type.startsWith('image/') || /\.(png|jpe?g|webp)$/i.test(f.name));
  if (files.length === 0) return;

  for (const f of files){
    const path = (f.webkitRelativePath || f.name);
    const kind = classifyPath(path);
    const url = URL.createObjectURL(f);
    const img = await imgFromURL(url);
    if (kind === 'background'){
      const id = 'user:bg:' + path;
      await idbPut('backgrounds', { id, title: f.name.replace(/\.[^.]+$/, ''), w: img.naturalWidth, h: img.naturalHeight, blob: f, createdAt: Date.now() });
    }else{
      const id = 'user:part:' + path;
      await idbPut('parts', { id, name: f.name.replace(/\.[^.]+$/, ''), w: img.naturalWidth, h: img.naturalHeight, blob: f, createdAt: Date.now() , addCount: 0 });
    }
  }
  const bgMeta = await idbGetAll('backgrounds');
  state.backgrounds = [];
  for(const m of bgMeta){
    const objUrl = URL.createObjectURL(m.blob);
    const im = await imgFromURL(objUrl);
    state.backgrounds.push({ id:m.id, title:m.title, w:m.w, h:m.h, url:objUrl, img: im });
  }
  const partsMeta = await idbGetAll('parts');
  state.parts = [];
  for(const m of partsMeta){
    const objUrl = URL.createObjectURL(m.blob);
    const im = await imgFromURL(objUrl);
    state.parts.push({ id:m.id, name:m.name, w:m.w, h:m.h, url:objUrl, img: im, color: m.color || '', size: m.size || '', addCount: (m.addCount||0) });
  }
  if (!state.bgId && state.backgrounds[0]) state.bgId = state.backgrounds[0].id;
  renderBgSelect();
  renderParts();
  updateColorFilterOptions?.();
  updatePMColorOptions?.();
  updatePMColorOptions?.();
  await loadTemplates?.();
  draw();
}

folderInput.onchange = async (e)=>{
  const fl = e.target.files;
  await importFolderFiles(fl);
  folderInput.value = '';
};


// ===== Library Export / Import (JSON) =====
const libExportBtn = document.getElementById('libExportBtn');
const libImportBtn = document.getElementById('libImportBtn');
const libImportInput = document.getElementById('libImportInput');

function blobToDataURL(blob){
  return new Promise((resolve, reject)=>{
    const fr = new FileReader();
    fr.onload = ()=> resolve(fr.result);
    fr.onerror = reject;
    fr.readAsDataURL(blob);
  });
}
async function dataURLToBlob(dataURL){
  const res = await fetch(dataURL);
  return await res.blob();
}
async function exportLibraryJSON(){
  const bgs = await idbGetAll('backgrounds');
  const pts = await idbGetAll('parts');
  const payload = { version: 2, exportedAt: Date.now(), backgrounds: [], parts: [] };
  for(const b of bgs){
    const dataURL = await blobToDataURL(b.blob);
    payload.backgrounds.push({ id: b.id, title: b.title, w: b.w, h: b.h, dataURL });
  }
  for(const p of pts){
    const dataURL = await blobToDataURL(p.blob);
    payload.parts.push({ id: p.id, name: p.name, w: p.w, h: p.h, color: (p.color||''), dataURL });
  }
  const str = JSON.stringify(payload);
  const blob = new Blob([str], {type: 'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `library_${new Date().toISOString().replace(/[:.]/g,'-')}.json`;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

async function importLibraryJSON(file){
  try{
    const txt = await file.text();
    const data = JSON.parse(txt);
    if (!data || (!Array.isArray(data.backgrounds) && !Array.isArray(data.parts))) {
      alert('JSON形式が不正です'); return;
    }
    if (Array.isArray(data.backgrounds)){
      for(const b of data.backgrounds){
        const blob = await dataURLToBlob(b.dataURL);
        await idbPut('backgrounds', { id: b.id || uid(), title: b.title||'背景', w: b.w, h: b.h, blob, createdAt: Date.now() });
      }
    }
    if (Array.isArray(data.parts)){
      for(const p of data.parts){
        const blob = await dataURLToBlob(p.dataURL);
        await idbPut('parts', { id: p.id || uid(), name: p.name||'パーツ', w: p.w, h: p.h, blob, createdAt: Date.now() , color: (p.color||''), addCount: 0 });
      }
    }
    // reload state from DB
    const bgMeta = await idbGetAll('backgrounds');
    state.backgrounds = [];
    for(const m of bgMeta){
      const objUrl = URL.createObjectURL(m.blob);
      const im = await imgFromURL(objUrl);
      state.backgrounds.push({ id:m.id, title:m.title, w:m.w, h:m.h, url:objUrl, img: im });
    }
    const partsMeta = await idbGetAll('parts');
    state.parts = [];
    for(const m of partsMeta){
      const objUrl = URL.createObjectURL(m.blob);
      const im = await imgFromURL(objUrl);
      state.parts.push({ id:m.id, name:m.name, w:m.w, h:m.h, url:objUrl, img: im, color: m.color || '', size: m.size || '', addCount: (m.addCount||0) });
    }
    if (!state.bgId && state.backgrounds[0]) state.bgId = state.backgrounds[0].id;
    renderBgSelect();
    renderParts();
    updateColorFilterOptions?.();
    draw();
    alert('ライブラリの読込が完了しました');
  }catch(e){
    console.error(e);
    alert('読込に失敗しました');
  }
}

libExportBtn.onclick = exportLibraryJSON;
libImportBtn.onclick = ()=> libImportInput.click();
libImportInput.onchange = async (e)=>{
  const f = e.target.files && e.target.files[0];
  if (!f) return;
  await importLibraryJSON(f);
  libImportInput.value = '';
};

// Drag & Drop from parts list
cvs.addEventListener('dragover', (e)=>{ e.preventDefault(); e.stopPropagation(); try{ e.dataTransfer.dropEffect = 'copy'; }catch(_){} });
cvs.addEventListener('drop', (e)=>{ e.stopPropagation(); if(__dropGuard) return; __dropGuard = TrueFix();
  e.preventDefault();
  const partId = (e.dataTransfer ? (e.dataTransfer.getData('application/x-part-id') || e.dataTransfer.getData('text/plain')) : '') || window.__dragPartId || '';
if(!partId) return;
  const {x, y} = canvasXY(e);
  addLayerFromPartAt(partId, x, y);
  window.__dragPartId = '';
  setTimeout(()=>{ __dropGuard = false; }, 0);
});

// Accept drop on stage wrapper too (in case user drops near canvas edges)
const stageEl = document.getElementById('stage');
function stageToCanvasXY(evt){
  const rect = cvs.getBoundingClientRect();
  const rx = (evt.clientX - rect.left) * (cvs.width / rect.width);
  const ry = (evt.clientY - rect.top) * (cvs.height / rect.height);
  return {x: rx, y: ry};
}
stageEl.addEventListener('dragover', (e)=>{ e.preventDefault(); e.stopPropagation(); return false; });
stageEl.addEventListener('drop', (e)=>{ e.preventDefault(); e.stopPropagation(); return false; });
// keyboard
window.addEventListener('keydown', (e)=>{
  if(!selectedId) return;
  const idx = state.layers.findIndex(l=>l.id===selectedId); if(idx<0) return;
  if(e.key==='Delete' || e.key==='Backspace'){
    state.layers.splice(idx,1); selectedId = ""; draw();
  }
  if(e.key===']'){ state.layers[idx].z = (state.layers[idx].z||0)+1; draw(); }
  if(e.key==='['){ state.layers[idx].z = (state.layers[idx].z||0)-1; draw(); }
});

// Templates helpers

// ===== Templates (Favorites) =====
function nowStamp(){
  const d=new Date();
  const pad=n=>String(n).padStart(2,'0');
  return `${d.getFullYear()}${pad(d.getMonth()+1)}${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}`;
}
function snapshotComposition(){
  return {
    bgId: state.bgId || '',
    zoom: state.zoom || 1,
    layers: state.layers.map(l=>({ partId:l.partId, x:l.x, y:l.y, scale:l.scale, rot:l.rot, flipX: !!l.flipX, z:l.z }))
  };
}
async function loadTemplates(){
  try{
    const list = await idbGetAll('templates');
    state.templates = list.sort((a,b)=>(b.createdAt||0)-(a.createdAt||0));
    // UI 反映
    if(tplSelect){
      const keep = tplSelect.value || '';
      tplSelect.innerHTML = '<option value=\"\">テンプレ適用</option>' + state.templates.map(t=>`<option value=\"${t.id}\">${t.name}</option>`).join('');
      if(keep && state.templates.some(t=>t.id===keep)) tplSelect.value = keep;
    }
  }catch(e){ console.warn('loadTemplates failed', e); }
}
async function saveTemplate(){
  try{
    const name = prompt('テンプレート名', `お気に入り_${nowStamp()}`);
    if(!name) return;
    const id = uid();
    const data = snapshotComposition();
    const rec = { id, name, ...data, createdAt: Date.now() };
    await idbPut('templates', rec);
    await loadTemplates();
    alert('テンプレートを保存しました');
  }catch(e){ alert('保存に失敗しました'); console.error(e); }
}
function applyTemplateData(tpl){
  if(!tpl) return;
  // 背景
  if(tpl.bgId && state.backgrounds.some(b=>b.id===tpl.bgId)){
    state.bgId = tpl.bgId;
    localStorage.setItem('bgId', state.bgId);
    renderBgSelect();
  }
  // レイヤー復元（新しい id を付与）
  state.layers = (tpl.layers||[]).map(l=>({ id: uid(), partId: l.partId, x:l.x, y:l.y, scale:l.scale, rot:l.rot, flipX: !!l.flipX, z:l.z }));
  selectedId = '';
  // ズームは適用しないと操作しづらい可能性があるため保持（必要なら有効化）
  // setZoom(tpl.zoom || 1);
  draw();
}
async function applySelectedTemplate(){
  const id = tplSelect && tplSelect.value;
  if(!id) return;
  const t = (state.templates||[]).find(x=>x.id===id);
  if(!t){ alert('テンプレートが見つかりません'); return; }
  applyTemplateData(t);
}
async function deleteSelectedTemplate(){
  const id = tplSelect && tplSelect.value;
  if(!id) return;
  if(!confirm('このテンプレートを削除しますか？')) return;
  try{
    await idbDelete('templates', id);
    await loadTemplates();
    tplSelect.value='';
  }catch(e){ alert('削除に失敗しました'); console.error(e); }
}
// Reset current composition
function resetComposition(){
  if(!confirm('現在の合成状態をリセットしますか？')) return;
  state.layers = [];
  selectedId = '';
  draw();
}

// Wire up events
tplSaveBtn && (tplSaveBtn.onclick = saveTemplate);
tplDeleteBtn && (tplDeleteBtn.onclick = deleteSelectedTemplate);
tplSelect && (tplSelect.onchange = applySelectedTemplate);
resetBtn && (resetBtn.onclick = resetComposition);

// export

exportBtn.onclick = ()=>{
  const bg = currentBg(); if(!bg) return;
  const defName = "output_20250903";
  const name = prompt("保存するファイル名を入力してください", defName);
  if(!name) return;
  const url = cvs.toDataURL('image/png');
  const a = document.createElement('a');
  a.href = url; a.download = name.endsWith(".png") ? name : name + ".png";
  a.click();
};



async function initFromDB(){
  try{
    
    await importFromManifest();
    const bgMeta = await idbGetAll('backgrounds');
    state.backgrounds = [];
    for(const m of bgMeta){
      const blob = m.blob;
      const objUrl = URL.createObjectURL(blob);
      const img = await imgFromURL(objUrl);
      state.backgrounds.push({ id:m.id, title:m.title, w:m.w, h:m.h, url:objUrl, img });
    }
    const savedBgId = localStorage.getItem('bgId') || '';
    if(savedBgId && state.backgrounds.some(b=>b.id===savedBgId)) state.bgId = savedBgId;
    else if(state.backgrounds[0]) state.bgId = state.backgrounds[0].id;

    const partsMeta = await idbGetAll('parts');
    state.parts = [];
    for(const m of partsMeta){
      const blob = m.blob;
      const objUrl = URL.createObjectURL(blob);
      const img = await imgFromURL(objUrl);
      state.parts.push({ id:m.id, name:m.name, w:m.w, h:m.h, url:objUrl, img, color: m.color || '', size: m.size || '' });
    }
  }catch(e){
    console.warn('IndexedDB init failed:', e);
  }
  
  // If empty on first run, seed sample assets
  const firstRunKey = 'seededSamplesV1';
  const seeded = localStorage.getItem(firstRunKey) === '1';
  if (!seeded) {
    if (state.backgrounds.length === 0 && SAMPLE_ASSETS.backgrounds.length){
      for (const s of SAMPLE_ASSETS.backgrounds){
        const res = await fetch(s.dataUrl);
        const blob = await res.blob();
        const img = await imgFromURL(s.dataUrl);
        const id = uid();
        await idbPut('backgrounds', { id, title: s.title, w: img.naturalWidth||800, h: img.naturalHeight||600, blob, createdAt: Date.now() });
      }
    }
    if (state.parts.length === 0 && SAMPLE_ASSETS.parts.length){
      for (const s of SAMPLE_ASSETS.parts){
        const res = await fetch(s.dataUrl);
        const blob = await res.blob();
        const img = await imgFromURL(s.dataUrl);
        const id = uid();
        await idbPut('parts', { id, name: s.name, w: img.naturalWidth||100, h: img.naturalHeight||100, blob, createdAt: Date.now() , addCount: 0 });
      }
    }
    localStorage.setItem(firstRunKey, '1');
    return initFromDB(); // reload
  }
  renderBgSelect();
  renderParts();
  updateColorFilterOptions?.();
  updatePMColorOptions?.();
  updatePMColorOptions?.();
  await loadTemplates?.();
  draw();
}


async function importFromManifest(){
  try{
    const isFile = location.protocol === 'file:';
    if (!isFile){
      const res = await fetch('assets/manifest.json');
      if(!res.ok) return;
      const man = await res.json();
      if (man.backgrounds){
        for (const m of man.backgrounds){
          const exists = await idbGet('backgrounds', m.id);
          if(!exists){
            const r = await fetch(m.path);
            const blob = await r.blob();
            const img = await imgFromURL(URL.createObjectURL(blob));
            await idbPut('backgrounds', { id:m.id, title:m.title, w: img.naturalWidth, h: img.naturalHeight, blob, createdAt: Date.now() });
          }
        }
      }
      if (man.parts){
        for (const m of man.parts){
          const exists = await idbGet('parts', m.id);
          if(!exists){
            const r = await fetch(m.path);
            const blob = await r.blob();
            const img = await imgFromURL(URL.createObjectURL(blob));
            await idbPut('parts', { id:m.id, name:m.name, w: img.naturalWidth, h: img.naturalHeight, blob, createdAt: Date.now() , addCount: 0 });
          }
        }
      }
      return;
    }
    // file:// fallback: directly load images into runtime state (no IDB write)
    const fallbackManifest = {
      backgrounds: [
        { id:"asset:bg:calm_hall",   title:"式場（落ち着き）", path:"assets/backgrounds/calm_hall.png" }
      ],
      parts: [
        { id:"asset:part:flower_white", name:"供花（白）", path:"assets/parts/flower_white.png" },
        { id:"asset:part:flower_color", name:"供花（カラフル）", path:"assets/parts/flower_color.png" },
        { id:"asset:part:ribbon",       name:"祭壇飾り（リボン）", path:"assets/parts/ribbon.png" }
      ]
    };
    function loadImg(path){
      return new Promise((resolve,reject)=>{
        const im = new Image();
        im.onload = ()=> resolve(im);
        im.onerror = reject;
        im.src = path;
      });
    }
    for (const m of fallbackManifest.backgrounds){
      const img = await loadImg(m.path);
      state.backgrounds.push({ id:m.id, title:m.title, w: img.naturalWidth, h: img.naturalHeight, url: m.path, img });
      if (!state.bgId) state.bgId = m.id;
    }
    for (const m of fallbackManifest.parts){
      const img = await loadImg(m.path);
      state.parts.push({ id:m.id, name:m.name, w: img.naturalWidth, h: img.naturalHeight, url: m.path, img });
    }
  }catch(e){
    console.warn('manifest import skipped:', e);
  }
}


// init
initFromDB();

// Double-click to cycle overlapping layers at point

// Double-click to cycle overlapping or nearby layers at point
cvs.addEventListener('dblclick', (e)=>{
  const {x:rx, y:ry} = canvasXY(e);
  let hits = hitLayersAt(rx, ry);
  // If only one (or none) is strictly under the point, broaden the search
  if (hits.length <= 1) {
    const R = 64; // pixel radius for "nearby" cycle tolerance
    const candidates = [];
    const top = [...state.layers].sort((a,b)=>(b.z??0)-(a.z??0));
    for (const L of top){
      const dx = rx - L.x, dy = ry - L.y;
      const d2 = dx*dx + dy*dy;
      if (d2 <= R*R) candidates.push(L);
    }
    if (candidates.length > 0) hits = candidates;
  }
  if(!hits.length) return;

  const ids = hits.map(h=>h.id);
  const key = __cycleKey(rx, ry);
  if (key !== __cycle.key){
    __cycle = { key, index: 0, ids };
  } else {
    const same = (__cycle.ids.length === ids.length) && __cycle.ids.every((v,i)=> v===ids[i]);
    if(!same) __cycle = { key, index: 0, ids };
    else __cycle.index = (__cycle.index + 1) % Math.max(1, ids.length);
  }
  const pick = hits[__cycle.index];
  selectedId = pick.id;
  drag = null; // avoid accidental drag as part of double-click
  draw();
});

</script>
<!-- ▼▼▼ ライブラリ入出力（マージ／アップサート）統合スクリプト ▼▼▼ -->
<script nonce="R4nd0mN0nc3">
(() => {
  const DB_NAME = 'composerDB';
  const DB_VERSION = 1;
  const STORE_BACKGROUNDS = 'backgrounds';
  const STORE_PARTS = 'parts';

  const $ = (sel) => document.querySelector(sel);

  function openDB(name, version, onUpgrade) {
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(name, version);
      req.onupgradeneeded = e => onUpgrade?.(req.result, e.oldVersion, e.newVersion);
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  }
  function txDone(tx) {
    return new Promise((res, rej) => {
      tx.oncomplete = () => res();
      tx.onerror = () => rej(tx.error);
      tx.onabort = () => rej(tx.error || new Error('transaction aborted'));
    });
  }
  function putAsync(store, value) {
    return new Promise((resolve, reject) => {
      const req = store.put(value);
      req.onsuccess = () => resolve();
      req.onerror = () => reject(req.error);
    });
  }
  function getAllAsync(store) {
    return new Promise((resolve, reject) => {
      const req = store.getAll();
      req.onsuccess = () => resolve(req.result || []);
      req.onerror = () => reject(req.error);
    });
  }

  function safeParseJson(text) {
    const clean = text.replace(/^\uFEFF/, '');
    try { return JSON.parse(clean); }
    catch (e) { throw new Error(`JSONのパースに失敗しました: ${e.message}`); }
  }

  function ensureStableId(rec, kind) {
    if (rec.id) return rec;
    const basis = [
      kind,
      rec.name || '',
      `${rec.width || ''}x${rec.height || ''}`,
      (rec.hash || '').slice(0,16),
    ].join(':');
    try { rec.id = basis || `${kind}:${crypto.randomUUID()}`; }
    catch { rec.id = basis || `${kind}:${Date.now()}:${Math.random().toString(36).slice(2)}`; }
    return rec;
  }

  async function importLibraryMerge(jsonText) {
    const data = safeParseJson(jsonText);
    if (!data || (!Array.isArray(data.backgrounds) && !Array.isArray(data.parts))) {
      throw new Error('想定スキーマと異なります（backgrounds / parts が見当たりません）');
    }
    const normalizeList = (arr, kind) => (arr || []).map(r => ensureStableId({ ...r }, kind));

    const db = await openDB(DB_NAME, DB_VERSION, (db) => {
      if (!db.objectStoreNames.contains(STORE_BACKGROUNDS)) {
        db.createObjectStore(STORE_BACKGROUNDS, { keyPath: 'id' });
      }
      if (!db.objectStoreNames.contains(STORE_PARTS)) {
        db.createObjectStore(STORE_PARTS, { keyPath: 'id' });
      }
    });

    const tx = db.transaction([STORE_BACKGROUNDS, STORE_PARTS], 'readwrite');
    const bg = tx.objectStore(STORE_BACKGROUNDS);
    const pt = tx.objectStore(STORE_PARTS);

    const jobs = [];
    for (const r of normalizeList(data.backgrounds, 'bg')) jobs.push(putAsync(bg, r));
    for (const r of normalizeList(data.parts, 'part'))        jobs.push(putAsync(pt, r));

    await Promise.all(jobs);
    await txDone(tx);
    db.close();
  }

  function blobToDataURL(blob) {
    return new Promise((resolve, reject) => {
      const fr = new FileReader();
      fr.onload = () => resolve(fr.result);
      fr.onerror = () => reject(fr.error);
      fr.readAsDataURL(blob);
    });
  }
  async function normalizeImageRecordForExport(rec) {
    const out = { ...rec };
    if (!out.dataURL) {
      if (out.blob instanceof Blob) {
        out.dataURL = await blobToDataURL(out.blob);
        delete out.blob;
      } else if (out.bytes) {
        try {
          const blob = new Blob([new Uint8Array(out.bytes)], { type: out.mime || 'application/octet-stream' });
          out.dataURL = await blobToDataURL(blob);
          delete out.bytes;
        } catch {}
      }
    }
    return out;
  }

  async function exportLibraryAsJson() {
    const db = await openDB(DB_NAME, DB_VERSION);
    const tx = db.transaction([STORE_BACKGROUNDS, STORE_PARTS], 'readonly');
    const [backgroundsRaw, partsRaw] = await Promise.all([
      getAllAsync(tx.objectStore(STORE_BACKGROUNDS)),
      getAllAsync(tx.objectStore(STORE_PARTS)),
    ]);
    await txDone(tx);
    db.close();

    const backgrounds = [];
    const parts = [];
    for (const r of backgroundsRaw) backgrounds.push(await normalizeImageRecordForExport(r));
    for (const r of partsRaw)       parts.push(await normalizeImageRecordForExport(r));

    const payload = {
      version: '1',
      meta: { generatedAt: new Date().toISOString(), app: 'funeral-composer (handoff)', mode: 'mergeable-json' },
      backgrounds,
      parts,
    };

    const text = JSON.stringify(payload, null, 2);
    const blob = new Blob([text], { type: 'application/json' });

    const ts = new Date();
    const pad = (n)=>String(n).padStart(2,'0');
    const fname = `composer_library_v1_${ts.getFullYear()}${pad(ts.getMonth()+1)}${pad(ts.getDate())}-${pad(ts.getHours())}${pad(ts.getMinutes())}${pad(ts.getSeconds())}.json`;

    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = fname;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(a.href);
  }

  function setupUI() {
    const pick = document.getElementById('btnPick');
    const input = document.getElementById('libInput');
    const exp = document.getElementById('btnExportJson');

    pick?.addEventListener('click', () => input?.click());
    input?.addEventListener('change', async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      try {
        const text = await file.text();
        await importLibraryMerge(text);
        console.log('[library-io] import done.');
        alert('ライブラリをマージ取り込みしました。');
      } catch (err) {
        console.error(err);
        alert('取り込みに失敗しました: ' + (err?.message || err));
      } finally {
        e.target.value = ''; // 同一ファイル再選択でも change 発火
      }
    });

    exp?.addEventListener('click', async () => {
      try {
        await exportLibraryAsJson();
      } catch (err) {
        console.error(err);
        alert('書き出しに失敗しました: ' + (err?.message || err));
      }
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', setupUI);
  } else {
    setupUI();
  }
})();
</script>
<!-- ▲▲▲ ライブラリ入出力（マージ／アップサート）統合スクリプト ▲▲▲ -->
<!-- ▼▼▼ 重なり選択の切り替え（オーバーラップ・サイクル） ▼▼▼ -->
<style>
  .__part-selected {
    outline: 2px solid #4ea1ff !important;
    outline-offset: 2px;
  }
</style>
<script nonce="R4nd0mN0nc3">
(() => {
  // 設定：対象となる「パーツ」要素のセレクタ（DOM型UI想定）
  // 既存のクラス名に合わせて増やせます。
  const PART_SELECTOR_CANDIDATES = ['[data-part]', '.part', '.piece', '.layer-item', '.sprite'];

  // 対象を判別する関数
  const isPartEl = (el) => {
    if (!el || el === document.body || el === document.documentElement) return false;
    for (const sel of PART_SELECTOR_CANDIDATES) {
      try { if (el.matches?.(sel)) return true; } catch {}
    }
    return false;
  };

  // 現在の選択状態
  let lastClick = { x: 0, y: 0, t: 0 };
  let cycle = { key: '', index: 0, hitIds: [] };
  const CLICK_DIST_PX = 6;      // 同一点判定の許容距離
  const CLICK_TIME_MS = 600;    // 同一地点連打とみなす時間

  // 選択の適用・解除
  function clearSelection() {
    document.querySelectorAll('.__part-selected').forEach(el => el.classList.remove('__part-selected'));
  }
  function applySelection(el) {
    clearSelection();
    el?.classList?.add('__part-selected');
    // 利用側で拾えるようにカスタムイベントも飛ばす
    el?.dispatchEvent(new CustomEvent('part-selected', { bubbles: true, detail: { element: el }}));
  }

  // elementsFromPoint で重なり順に列挙 → パーツだけ抽出
  function hitPartsAt(x, y) {
    const stack = document.elementsFromPoint(x, y) || [];
    return stack.filter(isPartEl);
  }

  // 同一地点連打かどうか
  function isRepeatedClick(x, y, t) {
    const dx = x - lastClick.x;
    const dy = y - lastClick.y;
    const dist2 = dx*dx + dy*dy;
    return (dist2 <= CLICK_DIST_PX*CLICK_DIST_PX) && (t - lastClick.t <= CLICK_TIME_MS);
  }

  // サイクルキーを生成（座標の丸めでキー化）
  function cycleKeyFor(x, y) {
    const q = (v) => Math.round(v / 8); // 8pxグリッドに丸め
    return `${q(x)}:${q(y)}`;
  }

  function selectNextAtPoint(x, y) {
    const hits = hitPartsAt(x, y);
    const ids = hits.map((el, i) => el.getAttribute('data-id') || el.id || `__idx_${i}`);

    const key = cycleKeyFor(x, y);
    if (key !== cycle.key) {
      // 新しい場所をクリックした：スタックを取り直し、最前面から選択
      cycle = { key, index: 0, hitIds: ids };
    } else {
      // 同じ場所：スタック構成が変わっていたら取り直し、そうでなければ次へ
      const same = (ids.length === cycle.hitIds.length) && ids.every((v, i) => v === cycle.hitIds[i]);
      if (!same) cycle = { key, index: 0, hitIds: ids };
      else cycle.index = (cycle.index + 1) % Math.max(1, ids.length);
    }

    const pick = hits[cycle.index];
    applySelection(pick);
    return pick;
  }

  // クリック動作：通常クリックは最前面、同一点連打 or Alt/Option でサイクル
  function onDocClick(ev) {
    const x = ev.clientX, y = ev.clientY, t = Date.now();
    const hits = hitPartsAt(x, y);
    if (hits.length === 0) return; // パーツ以外

    const repeated = isRepeatedClick(x, y, t);
    const doCycle = repeated || ev.altKey; // Alt(Option)クリックでも切替

    if (doCycle) {
      selectNextAtPoint(x, y);
    } else {
      // 先頭（最前面）を選択
      cycle = { key: cycleKeyFor(x, y), index: 0, hitIds: hits.map((el, i) => el.getAttribute('data-id') || el.id || `__idx_${i}`) };
      applySelection(hits[0]);
    }

    lastClick = { x, y, t };
    // 既存のドラッグ選択などに干渉しないよう、必要に応じて stopPropagation はコメントアウト
    // ev.stopPropagation();
  }

  // Tab キーで前後切替（フォーカスとは別の概念）
  function onKeyDown(ev) {
    if (ev.key === 'Tab') {
      const x = lastClick.x || (innerWidth/2);
      const y = lastClick.y || (innerHeight/2);
      selectNextAtPoint(x, y);
      ev.preventDefault();
    }
  }

  // 初期化
  document.addEventListener('click', onDocClick, true); // キャプチャで早めに拾う
  document.addEventListener('keydown', onKeyDown);

  // 公開API（必要に応じて使用可）
  window.__overlapSelect = {
    selectNextAtPoint,
    clearSelection,
    applySelection,
    setSelectors(list) { if (Array.isArray(list)) PART_SELECTOR_CANDIDATES.splice(0, PART_SELECTOR_CANDIDATES.length, ...list); }
  };

  console.log('[overlap-select] 有効化: クリック連打 or Altクリックで重なり選択を切替します。');
})();
</script>
<!-- ▲▲▲ 重なり選択の切り替え（オーバーラップ・サイクル） ▲▲▲ -->
<script nonce="R4nd0mN0nc3">
// --- Global delegation for per-card "回数リセット" ---
document.addEventListener('click', async (e)=>{
  const btn = e.target && (e.target.classList && e.target.classList.contains('pm-reset') ? e.target : e.target.closest && e.target.closest('.pm-reset'));
  if(!btn) return;
  e.preventDefault(); e.stopPropagation();
  const id = btn.getAttribute('data-id');
  if(!id) return;
  if(confirm('このパーツの追加回数を0にリセットしますか？')){
    await resetPartAddCount(id);
  }
});
// --- End delegation ---

</script>
<script nonce="R4nd0mN0nc3">
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('./sw.js', { scope: './' }).catch(console.error);
  });
}
</script>
</body>
</html>